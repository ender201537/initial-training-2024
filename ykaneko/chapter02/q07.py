def f(a):
    print(id(a))#１番目
    a = [6, 7, 8]
    print(id(a))#２番目

def g(a):
    a.append(1)

def somefunction():
    a0 = [1, 2, 3]
    f(a0)
    print(a0)

    a1 = [1, 2, 3]
    g(a1)
    print(a1)

somefunction()
# 実行結果の予想
# print(a0)を実行した際の出力は[1,2,3]になると予想
# print(a1)を実行した際の出力は[1,2,3,1]になると予想
# 考察
# 関数でリストを扱う際に「参照先の変更」と「リストの内容の変更」に違いがあるから。
# f関数ではローカル変数aの参照先が変更されただけで、元のa0に影響はない。
# g関数ではappendメソッドがリストの内容を直接変更するため、元のリストa1も更新されるのではないか。
# 関数 f は、引数 a に新しいリスト [6, 7, 8] を割り当てているだけで、外部の a0 に影響を与えない。
# g は引数 a（参照渡し）に対して .append(1) を適用しているため、外部の a1 にも変更が反映される。
# 各ポインタ(部屋)が違う。fはaを1番目と2番目の出力では違うポインタのaが出力される